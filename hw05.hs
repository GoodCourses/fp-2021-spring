-- | Тип дерева с множеством потомков.
-- 
data Tree a 
  = Node { nodeVal      :: a
         , nodeChildren :: [Tree a]
         }
  | EmptyTree


-- | В Хаскеле можно создавать объекты, используя метки их полей. 
--   Это позволяет не запутаться в порядке полей, когда их много.
--
exampleTree :: Tree Int
exampleTree = 
  Node { nodeVal = 3
       , nodeChildren = [child1, child2]
       }
  where
    child1 = Node 1 []
    child2 = Node 2 []

-- | Также удобно использовать метки полей для того, чтобы получить значение какого-то поля.
--
childrenVals :: Tree a  -> [a]
childrenVals EmptyTree = []
--   Далее запись `a@Node{}` означает следующее: 
--     1. Мы ожидаем, что аргумент функции будет паттерн-матчиться на конструктор 'Node'.
--     2. Аргументы конструктора мы не хотим записывать в переменные.
--        Поэтому добавляем после его названия пустые скобочки `{}`.
--     3. Запись `a@...` в аргументе функции означает, аргумент будет полностью помещён в переменную 'a'. 
--        При этом не важно, какой паттерн-матчинг мы организовываем после `@`.
--
childrenVals a@Node{}  = map nodeVal $ nodeChildren a

-- 1. Функция суммирует все значения в дереве. 
--    Паттерн-матчиться на аргументы конструктора в данном задании нельзя. Используйте метки полей!
--    Функция должна быть хвосторекурсивной. (0.25 б)
--
sumIntVals :: Tree Int -> Int
sumIntVals = undefined

-- 2. Функция сравнивает два списка лексикографически. 
--    Возвращает 'True', если первый список меньше второго. Возвращает 'False' в противном случае.
--    Для сравнения нужно использовать операторы (<), (<=), (>), (>=), (==),
--    которые есть у всех представителей класса типов 'Ord'. (0.5 б)
--
isLessList :: Ord a => [a] -> [a] -> Bool
isLessList = undefined

-- 3.1. Применяет функцию @f@ к списку @l@. 
--      Если на каком-то элементе списка функция @f@ вернула 'Nothing',
--      то результатом работы функции @mapWithATwist@ тоже будет 'Nothing'. (0.5 б)
--
mapWithATwist :: (a -> Maybe b) -> [a] -> Maybe [b]
mapWithATwist f l = undefined

-- В Хаскеле есть оператор композиции: (.)
-- Работает он точно так же, как комбинатор B, но позволяет естественно и лаконично использовать композицию функций.

myFuncAB :: a -> b
myFuncAB = undefined

myFuncBC :: b -> c
myFuncBC = undefined

-- | Смотрите, как красиво и естесвенно выглядит функция, являющаяся композицией 
--   @myFuncBC@ и @myFuncAB@, если реализовать её с помощью комбинатора (.)
--
compABBC :: a -> c
compABBC = myFuncBC . myFuncAB

-- 3.2. Реализуйте @mapViaMapWithATwist@: обычный @map@. 
--      В реализации нельзя использовать паттерн-матчинг, но нужно использовать @mapWithATwist@.
--      Также в этом задании обязательно нужно использовать оператор композиции! (0.5 б)
--
mapViaMapWithATwist :: (a -> b) -> [a] -> [b]
mapViaMapWithATwist f = undefined

-- | В Хаскеле можно создавать бесконечные списки.
--
infList :: [Int]
infList = helper 0
  where
    helper :: Int -> [Int]
    helper x = x : helper (x + 1)

-- | Из-за ленивости они даже будут работать! 
--   В том плане, что они будут вычисляться ровно до того момента, до которого нам надо.
--
--   Пример ниже вычислится и будет равен [0, 1, 2, 3].
-- 
vals1234 :: [Int]
vals1234 = take 4 infList

-- 4.1 Задайте бесконечный список всех чисел Фибоначчи. 
--    Элементы списка должны вчисляться за O(n), где n — номер числа Фибоначчи. (1 б)
--
fibs :: [Int]
fibs = undefined

-- 4.2 Считает сумму всех элементов списка, которые находятся на позиции, 
--     __индекс__ которой является числом Фибоначчи. (1 б)
--
fibSum :: [Int] -> Int
fibSum = undefined

-- 5. Достаёт из списка все подсписки заданной длины. (1 б)
--
--    Пример:
--      sublists [1, 2, 3] 2 = [[1, 2], [2, 3]]
--    
sublists :: [a] -> Int -> [[a]]
sublists = undefined

-- 6. Создайте тип 'Term', соответствующий терму в лямбда-исчислении. 
--    Для всех полей должны быть определены соотвествующие метки полей. (0.5 б)
--
data Term = YourTerm

-- 7. Реализуйте функции free and bound, которые находят все свободные и 
--    связанные переменные в терме, соответственно. (0.5 б)

free :: Term -> [String]
free = undefined

bound :: Term -> [String]
bound = undefined

-- 8. Реализуйте функцию, которая производит подстановку терма по правилам
--    лямбда-исчисления. (1 б)
--
substitution :: Term -> String -> Term -> Term
substitution term varName newVal = undefined
